using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;
using XrmFramework.Analyzers.Extensions;

namespace XrmFramework.Analyzers.Generators
{

    [Generator]
    public class EnumGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var enumTypes = context.SyntaxProvider
                                .CreateSyntaxProvider(CouldBeEnumerationAsync, GetEnumTypeOrNull)
                                .Where(type => type is not null)
                                .Collect();

            context.RegisterSourceOutput(enumTypes, GenerateCode);
        }

        private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol?> enumerations)
        {
            try
            {
                if (enumerations.IsDefaultOrEmpty)
                    return;

                foreach (var type in enumerations)
                {
                    if (type is null)
                    {
                        continue;
                    }

                    var code = GenerateCode(type);
                    var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                           ? null
                           : $"{type.ContainingNamespace}.";

                    context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
                }
            }
            catch (NullReferenceException e)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("ERROR12", "Erreur", e.StackTrace, "Code", DiagnosticSeverity.Error, true), null));
            }
        }

        private static string GenerateCode(ITypeSymbol type)
        {
            var ns = type.ContainingNamespace.IsGlobalNamespace
                  ? null
                  : type.ContainingNamespace.ToString();
            var name = type.Name;
            var items = GetItemNames(type).ToList();

            var itemsText = new StringBuilder();
            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];

                if (item.isObsolete)
                {
                    itemsText.AppendLine("#pragma warning disable CS0612");
                }

                itemsText.Append("            ").Append(item.name);

                if (i != items.Count - 1)
                {
                    itemsText.AppendLine(",");
                }
                else
                {
                    itemsText.AppendLine();
                }

                if (item.isObsolete)
                {
                    itemsText.AppendLine("#pragma warning restore CS0612");
                }
            }

            return @$"// <auto-generated />

using System.Collections.Generic;

{(ns is null ? null : $@"namespace {ns}
{{")}
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
        return new[] {{ 
{itemsText}
        }};
      }}
   }}
{(ns is null ? null : @"}
")}";
        }

        private static IEnumerable<(string name, bool isObsolete)> GetItemNames(ITypeSymbol type)
            => type.GetMembers()
                .Select(m =>
                {
                    if (!m.IsStatic ||
                        m.DeclaredAccessibility != Accessibility.Public ||
                        m is not IFieldSymbol field)
                        return (null, false);

                    return SymbolEqualityComparer.Default.Equals(field.Type, type)
                        ? (field.Name, field.GetAttributes().Any(a => a.AttributeClass.GetFullMetadataName() == "System.ObsoleteAttribute"))
                        : (null, false);
                })
                .Where(field => !string.IsNullOrWhiteSpace(field.Name))!;


        private static bool CouldBeEnumerationAsync(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (syntaxNode is not AttributeSyntax attribute)
                return false;

            var name = ExtractName(attribute.Name);

            return name is "EnumGeneration" or "EnumGenerationAttribute";
        }

        private static string? ExtractName(NameSyntax? name)
        {
            while (name != null)
            {
                switch (name)
                {
                    case IdentifierNameSyntax ins:
                        return ins.Identifier.Text;

                    case QualifiedNameSyntax qns:
                        name = qns.Right;
                        break;

                    default:
                        return null;
                }
            }

            return null;
        }

        private static ITypeSymbol? GetEnumTypeOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // "attribute.Parent" is "AttributeListSyntax"
            // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
            if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
                return null;

            var type = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

            return type is null || !IsEnumeration(type) ? null : type;
        }

        private static bool IsEnumeration(ISymbol type)
        {
            return type.GetAttributes()
                       .Any(a => a.AttributeClass?.Name == "EnumGenerationAttribute" &&
                                 a.AttributeClass.ContainingNamespace is
                                 {
                                     Name: "XrmFramework",
                                     ContainingNamespace.IsGlobalNamespace: true
                                 });
        }
    }

}